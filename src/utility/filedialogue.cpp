#include "filedialogue.hpp"

using std::string, std::vector;

// Opens a choose-file dialogue in the default directory
string openFileDialogue()
{
    return openFileDialogue("", "", {});
}
// Opens a choose-dialogue with a specific directory
string openFileDialogue(const string& start_path)
{
    return openFileDialogue(start_path, "", {});
}



// Words don't describe my mild to slightly-more-than-mild disdain for the WIN32 API
#ifdef _WIN32
// Opens a choose-file dialogue with a specific directory and extension(s)
string openFileDialogue(const string& start_path,
                        const string& filter_name,
                        const vector<string>& extensions)
{
    // Code generated by ChatGPT with much, MUCH fiddling.
    // This should be inverted, because this nesting is horrible,
    // but it's almost midnight and I cannot be bothered at the moment.
    // It works, it's fine, I hate this.

    IFileOpenDialog* pFileOpen;
    HRESULT hr = CoCreateInstance(CLSID_FileOpenDialog, NULL, CLSCTX_ALL, IID_IFileOpenDialog, reinterpret_cast<void**>(&pFileOpen));
    if (SUCCEEDED(hr))
    {
        if (!start_path.empty())
        {
            std::wstring filePath = std::wstring(start_path.begin(), start_path.end());
            IShellItem* pItem;
            hr = SHCreateItemFromParsingName(filePath.c_str(), NULL, IID_IShellItem, reinterpret_cast<void**>(&pItem));
            if (SUCCEEDED(hr))
            {
                pFileOpen->SetDefaultFolder(pItem);
                pItem->Release();
            }
        }

        // If any extensions are passed, set the file type filter
        if(!extensions.empty())
        {
            // Build the filter string
            std::string filter;
            for (const auto& ext : extensions)
            {
                filter += "*." + ext + ";";
            }
            filter = filter.substr(0, filter.length() - 1);

            // Convert the filter string to a wide string
            std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter;
            std::wstring filterWString = converter.from_bytes(filter);
            std::wstring filterNameWString = converter.from_bytes(filter_name + " (" + filter + ")");

            // Set the filter on the common item dialog
            COMDLG_FILTERSPEC fileTypes[] = { { filterNameWString.c_str(), filterWString.c_str() } };
            pFileOpen->SetFileTypes(1, fileTypes);
        }

        hr = pFileOpen->Show(NULL);
        if (SUCCEEDED(hr))
        {
            IShellItem* pItem;
            hr = pFileOpen->GetResult(&pItem);
            if (SUCCEEDED(hr))
            {
                PWSTR filePath;
                hr = pItem->GetDisplayName(SIGDN_FILESYSPATH, &filePath);
                if (SUCCEEDED(hr))
                {
                    std::wstring_convert<std::codecvt_utf8<wchar_t>, wchar_t> converter;
                    std::string result = converter.to_bytes(filePath);
                    CoTaskMemFree(filePath);
                    pItem->Release();
                    pFileOpen->Release();
                    return result;
                }
                pItem->Release();
            }
        }
        pFileOpen->Release();
    }
    return "";
}

// NOTE: Linux implementations are currently untested
#elif __linux__

// Opens a choose-file dialogue with a specific directory and extension(s)
string openFileDialogue(const string& start_path, const vector<string>& extentions)
{
    string file_path;

    // Create a file chooser dialog
    GtkWidget *dialog = gtk_file_chooser_dialog_new("Open File",
                                                    NULL,
                                                    GTK_FILE_CHOOSER_ACTION_OPEN,
                                                    "_Cancel",
                                                    GTK_RESPONSE_CANCEL,
                                                    "_Open",
                                                    GTK_RESPONSE_ACCEPT,
                                                    NULL);

    // Set the starting directory, if provided
    if (!start_path.empty())
    {
        gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(dialog), start_path.c_str());
    }

    // Run the dialog and get the response
    if (gtk_dialog_run(GTK_DIALOG(dialog)) == GTK_RESPONSE_ACCEPT)
    {
        char *filename = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dialog));
        file_path = filename;
        g_free(filename);
    }

    // Destroy the dialog
    gtk_widget_destroy(dialog);

    return file_path;
}

#endif